/* automatically generated by rust-bindgen 0.66.1 */

pub type Torus = u64;
pub type Binary = i16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub coeffs: *mut Torus,
    pub N: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeffs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_2),
            "::",
            stringify!(coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_2),
            "::",
            stringify!(N)
        )
    );
}
pub type TorusPolynomial = *mut _bindgen_ty_2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub coeffs: *mut f64,
    pub N: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeffs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_3),
            "::",
            stringify!(coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_3),
            "::",
            stringify!(N)
        )
    );
}
pub type DFT_Polynomial = *mut _bindgen_ty_3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub coeffs: *mut Binary,
    pub N: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeffs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_4),
            "::",
            stringify!(coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_4),
            "::",
            stringify!(N)
        )
    );
}
pub type BinaryPolynomial = *mut _bindgen_ty_4;
pub type IntPolynomial = TorusPolynomial;
pub type Integer = Torus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub a: *mut Torus,
    pub b: Torus,
    pub n: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_5>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_5),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_5),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_5),
            "::",
            stringify!(n)
        )
    );
}
pub type TLWE = *mut _bindgen_ty_5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub s: *mut Integer,
    pub n: ::libc::c_int,
    pub sigma: f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_6>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_6),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_6),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigma) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_6),
            "::",
            stringify!(sigma)
        )
    );
}
pub type TLWE_Key = *mut _bindgen_ty_6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub s: *mut *mut *mut TLWE,
    pub base_bit: ::libc::c_int,
    pub t: ::libc::c_int,
    pub n: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_7>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).base_bit) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(base_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(n)
        )
    );
}
pub type TLWE_KS_Key = *mut _bindgen_ty_7;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub a: *mut TorusPolynomial,
    pub b: TorusPolynomial,
    pub k: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_8>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_8),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_8),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_8),
            "::",
            stringify!(k)
        )
    );
}
pub type TRLWE = *mut _bindgen_ty_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub a: *mut DFT_Polynomial,
    pub b: DFT_Polynomial,
    pub k: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_9> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_9>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_9))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_9),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_9),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_9),
            "::",
            stringify!(k)
        )
    );
}
pub type TRLWE_DFT = *mut _bindgen_ty_9;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub s: *mut IntPolynomial,
    pub k: ::libc::c_int,
    pub sigma: f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_10> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_10>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_10))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_10),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_10),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigma) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_10),
            "::",
            stringify!(sigma)
        )
    );
}
pub type TRLWE_Key = *mut _bindgen_ty_10;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub s: *mut *mut TRLWE_DFT,
    pub base_bit: ::libc::c_int,
    pub t: ::libc::c_int,
    pub k: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_11> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_11>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_11>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_11))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_11),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).base_bit) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_11),
            "::",
            stringify!(base_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_11),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_11),
            "::",
            stringify!(k)
        )
    );
}
pub type TRLWE_KS_Key = *mut _bindgen_ty_11;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub s: *mut *mut *mut *mut TRLWE,
    pub base_bit: ::libc::c_int,
    pub t: ::libc::c_int,
    pub torus_base: ::libc::c_int,
    pub n: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_12>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_12>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_12),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).base_bit) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_12),
            "::",
            stringify!(base_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_12),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).torus_base) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_12),
            "::",
            stringify!(torus_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_12),
            "::",
            stringify!(n)
        )
    );
}
pub type LUT_Packing_KS_Key = *mut _bindgen_ty_12;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub s: *mut *mut *mut TRLWE,
    pub base_bit: ::libc::c_int,
    pub t: ::libc::c_int,
    pub n: ::libc::c_int,
    pub include_b: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_13> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_13>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_13>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_13))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_13),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).base_bit) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_13),
            "::",
            stringify!(base_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_13),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_13),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).include_b) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_13),
            "::",
            stringify!(include_b)
        )
    );
}
pub type Generic_KS_Key = *mut _bindgen_ty_13;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub samples: *mut TRLWE,
    pub l: ::libc::c_int,
    pub Bg_bit: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_14> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_14>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_14>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_14))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_14),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_14),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bg_bit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_14),
            "::",
            stringify!(Bg_bit)
        )
    );
}
pub type TRGSW = *mut _bindgen_ty_14;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub samples: *mut TRLWE_DFT,
    pub l: ::libc::c_int,
    pub Bg_bit: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_15> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_15>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_15>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_15))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_15),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_15),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bg_bit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_15),
            "::",
            stringify!(Bg_bit)
        )
    );
}
pub type TRGSW_DFT = *mut _bindgen_ty_15;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub trlwe_key: TRLWE_Key,
    pub l: ::libc::c_int,
    pub Bg_bit: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_16> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_16>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_16>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_16))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trlwe_key) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_16),
            "::",
            stringify!(trlwe_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_16),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bg_bit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_16),
            "::",
            stringify!(Bg_bit)
        )
    );
}
pub type TRGSW_Key = *mut _bindgen_ty_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub positive: TRGSW_DFT,
    pub negative: TRGSW_DFT,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_17> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_17>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_17>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_17))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).positive) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_17),
            "::",
            stringify!(positive)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).negative) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_17),
            "::",
            stringify!(negative)
        )
    );
}
pub type TRGSW_REG = *mut _bindgen_ty_17;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub s: *mut TRGSW_DFT,
    pub su: *mut TRGSW,
    pub n: ::libc::c_int,
    pub k: ::libc::c_int,
    pub N: ::libc::c_int,
    pub Bg_bit: ::libc::c_int,
    pub l: ::libc::c_int,
    pub unfolding: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_18> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_18>(),
        40usize,
        concat!("Size of: ", stringify!(_bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_18>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_18))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).su) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(su)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bg_bit) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(Bg_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unfolding) as usize - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_18),
            "::",
            stringify!(unfolding)
        )
    );
}
pub type Bootstrap_Key = *mut _bindgen_ty_18;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub s: *mut TRGSW_DFT,
    pub su: *mut TRGSW,
    pub ak: *mut TRLWE_KS_Key,
    pub n: ::libc::c_int,
    pub k: ::libc::c_int,
    pub N: ::libc::c_int,
    pub Bg_bit: ::libc::c_int,
    pub l: ::libc::c_int,
    pub unfolding: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_19> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_19>(),
        48usize,
        concat!("Size of: ", stringify!(_bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_19>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_19))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).su) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(su)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ak) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(ak)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bg_bit) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(Bg_bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unfolding) as usize - ptr as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_19),
            "::",
            stringify!(unfolding)
        )
    );
}
pub type Bootstrap_GA_Key = *mut _bindgen_ty_19;
extern "C" {
    pub fn torus2double(x: Torus) -> f64;
}
extern "C" {
    pub fn double2torus(x: f64) -> Torus;
}
extern "C" {
    pub fn torus2int(x: Torus, log_scale: ::libc::c_int) -> u64;
}
extern "C" {
    pub fn int2torus(x: u64, log_scale: ::libc::c_int) -> Torus;
}
extern "C" {
    pub fn polynomial_new_torus_polynomial(N: ::libc::c_int)
        -> TorusPolynomial;
}
extern "C" {
    pub fn polynomial_new_array_of_torus_polynomials(
        N: ::libc::c_int,
        size: ::libc::c_int,
    ) -> *mut TorusPolynomial;
}
extern "C" {
    pub fn polynomial_new_DFT_polynomial(N: ::libc::c_int) -> DFT_Polynomial;
}
extern "C" {
    pub fn polynomial_new_array_of_polynomials_DFT(
        N: ::libc::c_int,
        size: ::libc::c_int,
    ) -> *mut DFT_Polynomial;
}
extern "C" {
    pub fn polynomial_new_binary_polynomial(
        N: ::libc::c_int,
    ) -> BinaryPolynomial;
}
extern "C" {
    pub fn polynomial_decompose(
        out: *mut TorusPolynomial,
        in_: TorusPolynomial,
        Bg_bit: ::libc::c_int,
        l: ::libc::c_int,
    );
}
extern "C" {
    pub fn polynomial_torus_scale(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        log_scale: ::libc::c_int,
    );
}
extern "C" {
    pub fn polynomial_add_torus_polynomials(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_addto_torus_polynomial(
        out: TorusPolynomial,
        in_: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_sub_torus_polynomials(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_subto_torus_polynomial(
        out: TorusPolynomial,
        in_: TorusPolynomial,
    );
}
extern "C" {
    pub fn torus_polynomial_mul_by_xai(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        a: ::libc::c_int,
    );
}
extern "C" {
    pub fn torus_polynomial_mul_by_xai_addto(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        a: ::libc::c_int,
    );
}
extern "C" {
    pub fn torus_polynomial_mul_by_xai_minus_1(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        a: ::libc::c_int,
    );
}
extern "C" {
    pub fn polynomial_naive_mul_binary(
        out: BinaryPolynomial,
        in1: BinaryPolynomial,
        in2: BinaryPolynomial,
    );
}
extern "C" {
    pub fn polynomial_naive_mul_torus(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_mul_torus(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_mul_addto_torus(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_naive_mul_addto_torus(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_naive_mul_addto_torus_binary(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: BinaryPolynomial,
    );
}
extern "C" {
    pub fn polynomial_DFT_to_torus(out: TorusPolynomial, in_: DFT_Polynomial);
}
extern "C" {
    pub fn polynomial_torus_to_DFT(out: DFT_Polynomial, in_: TorusPolynomial);
}
extern "C" {
    pub fn polynomial_mul_DFT(
        out: DFT_Polynomial,
        in1: DFT_Polynomial,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn polynomial_mul_addto_DFT(
        out: DFT_Polynomial,
        in1: DFT_Polynomial,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn polynomial_sub_DFT_polynomials(
        out: DFT_Polynomial,
        in1: DFT_Polynomial,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn polynomial_copy_torus_polynomial(
        out: TorusPolynomial,
        in_: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_negate_torus_polynomial(
        out: TorusPolynomial,
        in_: TorusPolynomial,
    );
}
extern "C" {
    pub fn polynomial_copy_DFT_polynomial(
        out: DFT_Polynomial,
        in_: DFT_Polynomial,
    );
}
extern "C" {
    pub fn free_polynomial(p: *mut ::libc::c_void);
}
extern "C" {
    pub fn free_DFT_polynomial(p: DFT_Polynomial);
}
extern "C" {
    pub fn free_array_of_polynomials(
        p: *mut ::libc::c_void,
        size: ::libc::c_int,
    );
}
extern "C" {
    pub fn init_fft(N: ::libc::c_int);
}
extern "C" {
    pub fn polynomial_full_mul_with_scale(
        out: TorusPolynomial,
        in1: TorusPolynomial,
        in2: TorusPolynomial,
        bit_size: ::libc::c_int,
        scale_bit: ::libc::c_int,
    );
}
extern "C" {
    pub fn polynomial_permute(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        gen: u64,
    );
}
extern "C" {
    pub fn polynomial_add_DFT_polynomials(
        out: DFT_Polynomial,
        in1: DFT_Polynomial,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn polynomial_decompose_i(
        out: TorusPolynomial,
        in_: TorusPolynomial,
        Bg_bit: ::libc::c_int,
        l: ::libc::c_int,
        i: ::libc::c_int,
    );
}
extern "C" {
    pub fn tlwe_alloc_key(n: ::libc::c_int, sigma: f64) -> TLWE_Key;
}
extern "C" {
    pub fn tlwe_new_binary_key(n: ::libc::c_int, sigma: f64) -> TLWE_Key;
}
extern "C" {
    pub fn tlwe_new_bounded_key(
        n: ::libc::c_int,
        bound: u64,
        sigma: f64,
    ) -> TLWE_Key;
}
extern "C" {
    pub fn tlwe_load_new_key(fd: *mut FILE) -> TLWE_Key;
}
extern "C" {
    pub fn tlwe_load_new_KS_key(fd: *mut FILE) -> TLWE_KS_Key;
}
extern "C" {
    pub fn tlwe_save_KS_key(fd: *mut FILE, key: TLWE_KS_Key);
}
extern "C" {
    pub fn tlwe_alloc_sample(n: ::libc::c_int) -> TLWE;
}
extern "C" {
    pub fn tlwe_alloc_sample_array(
        count: ::libc::c_int,
        n: ::libc::c_int,
    ) -> *mut TLWE;
}
extern "C" {
    pub fn tlwe_save_key(fd: *mut FILE, key: TLWE_Key);
}
extern "C" {
    pub fn tlwe_new_noiseless_trivial_sample(
        m: Torus,
        n: ::libc::c_int,
    ) -> TLWE;
}
extern "C" {
    pub fn tlwe_noiseless_trivial_sample(out: TLWE, m: Torus);
}
extern "C" {
    pub fn tlwe_sample(out: TLWE, m: Torus, key: TLWE_Key);
}
extern "C" {
    pub fn tlwe_copy(out: TLWE, in_: TLWE);
}
extern "C" {
    pub fn tlwe_new_sample(m: Torus, key: TLWE_Key) -> TLWE;
}
extern "C" {
    pub fn tlwe_load_new_sample(fd: *mut FILE, n: ::libc::c_int) -> TLWE;
}
extern "C" {
    pub fn tlwe_load_sample(fd: *mut FILE, c: TLWE);
}
extern "C" {
    pub fn tlwe_save_sample(fd: *mut FILE, c: TLWE);
}
extern "C" {
    pub fn trlwe_load_new_DFT_sample(
        fd: *mut FILE,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE_DFT;
}
extern "C" {
    pub fn trlwe_save_DFT_sample(fd: *mut FILE, c: TRLWE_DFT);
}
extern "C" {
    pub fn tlwe_phase(c: TLWE, key: TLWE_Key) -> Torus;
}
extern "C" {
    pub fn tlwe_add(out: TLWE, in1: TLWE, in2: TLWE);
}
extern "C" {
    pub fn tlwe_addto(out: TLWE, in_: TLWE);
}
extern "C" {
    pub fn tlwe_scale(out: TLWE, in1: TLWE, in2: Torus);
}
extern "C" {
    pub fn tlwe_scale_addto(out: TLWE, in1: TLWE, in2: Torus);
}
extern "C" {
    pub fn tlwe_sub(out: TLWE, in1: TLWE, in2: TLWE);
}
extern "C" {
    pub fn tlwe_subto(out: TLWE, in_: TLWE);
}
extern "C" {
    pub fn tlwe_negate(out: TLWE, in_: TLWE);
}
extern "C" {
    pub fn tlwe_new_KS_key(
        out_key: TLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> TLWE_KS_Key;
}
extern "C" {
    pub fn tlwe_keyswitch(out: TLWE, in_: TLWE, ks_key: TLWE_KS_Key);
}
extern "C" {
    pub fn free_tlwe(p: TLWE);
}
extern "C" {
    pub fn free_tlwe_array(p: *mut TLWE, count: ::libc::c_int);
}
extern "C" {
    pub fn free_tlwe_key(key: TLWE_Key);
}
extern "C" {
    pub fn free_tlwe_ks_key(key: TLWE_KS_Key);
}
extern "C" {
    pub fn tlwe_mul(
        out: TLWE,
        in1: TLWE,
        in2: TLWE,
        delta: ::libc::c_int,
        ksk: Generic_KS_Key,
        rlk: TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_alloc_key(
        N: ::libc::c_int,
        k: ::libc::c_int,
        sigma: f64,
    ) -> TRLWE_Key;
}
extern "C" {
    pub fn trlwe_new_binary_key(
        N: ::libc::c_int,
        k: ::libc::c_int,
        sigma: f64,
    ) -> TRLWE_Key;
}
extern "C" {
    pub fn trlwe_new_bounded_key(
        N: ::libc::c_int,
        k: ::libc::c_int,
        bound: u64,
        sigma: f64,
    ) -> TRLWE_Key;
}
extern "C" {
    pub fn trlwe_load_new_key(fd: *mut FILE) -> TRLWE_Key;
}
extern "C" {
    pub fn trlwe_save_key(fd: *mut FILE, key: TRLWE_Key);
}
extern "C" {
    pub fn trlwe_alloc_new_sample(k: ::libc::c_int, N: ::libc::c_int) -> TRLWE;
}
extern "C" {
    pub fn trlwe_alloc_new_sample_array(
        count: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> *mut TRLWE;
}
extern "C" {
    pub fn trlwe_alloc_new_DFT_sample_array(
        count: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> *mut TRLWE_DFT;
}
extern "C" {
    pub fn trlwe_load_new_sample(
        fd: *mut FILE,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE;
}
extern "C" {
    pub fn trlwe_load_sample(fd: *mut FILE, c: TRLWE);
}
extern "C" {
    pub fn trlwe_save_sample(fd: *mut FILE, c: TRLWE);
}
extern "C" {
    pub fn trlwe_alloc_new_DFT_sample(
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE_DFT;
}
extern "C" {
    pub fn trlwe_load_DFT_sample(fd: *mut FILE, c: TRLWE_DFT);
}
extern "C" {
    pub fn trlwe_new_noiseless_trivial_sample(
        m: TorusPolynomial,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE;
}
extern "C" {
    pub fn trlwe_noiseless_trivial_sample(out: TRLWE, m: TorusPolynomial);
}
extern "C" {
    pub fn trlwe_new_sample(m: TorusPolynomial, key: TRLWE_Key) -> TRLWE;
}
extern "C" {
    pub fn trlwe_sample(out: TRLWE, m: TorusPolynomial, key: TRLWE_Key);
}
extern "C" {
    pub fn trlwe_phase(out: TorusPolynomial, in_: TRLWE, key: TRLWE_Key);
}
extern "C" {
    pub fn trlwe_from_DFT(out: TRLWE, in_: TRLWE_DFT);
}
extern "C" {
    pub fn trlwe_to_DFT(out: TRLWE_DFT, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_decompose(
        out: *mut TorusPolynomial,
        in_: TRLWE,
        Bg_bit: ::libc::c_int,
        l: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_add(out: TRLWE, in1: TRLWE, in2: TRLWE);
}
extern "C" {
    pub fn trlwe_addto(out: TRLWE, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_sub(out: TRLWE, in1: TRLWE, in2: TRLWE);
}
extern "C" {
    pub fn trlwe_DFT_sub(out: TRLWE_DFT, in1: TRLWE_DFT, in2: TRLWE_DFT);
}
extern "C" {
    pub fn trgsw_DFT_add(out: TRGSW_DFT, in1: TRGSW_DFT, in2: TRGSW_DFT);
}
extern "C" {
    pub fn trlwe_subto(out: TRLWE, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_DFT_mul_by_polynomial(
        out: TRLWE_DFT,
        in_: TRLWE_DFT,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn trlwe_DFT_mul_addto_by_polynomial(
        out: TRLWE_DFT,
        in_: TRLWE_DFT,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn trlwe_mul_by_xai(out: TRLWE, in_: TRLWE, a: ::libc::c_int);
}
extern "C" {
    pub fn trlwe_mul_by_xai_addto(out: TRLWE, in_: TRLWE, a: ::libc::c_int);
}
extern "C" {
    pub fn trlwe_mul_by_xai_minus_1(out: TRLWE, in_: TRLWE, a: ::libc::c_int);
}
extern "C" {
    pub fn trlwe_extract_tlwe(out: TLWE, in_: TRLWE, idx: ::libc::c_int);
}
extern "C" {
    pub fn trlwe_extract_tlwe_key(out: TLWE_Key, in_: TRLWE_Key);
}
extern "C" {
    pub fn trlwe_mv_extract_tlwe(
        out: *mut TLWE,
        in_: TRLWE,
        amount: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_mv_extract_tlwe_scaling(
        out: TLWE,
        in_: TRLWE,
        scale: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_mv_extract_tlwe_scaling_addto(
        out: TLWE,
        in_: TRLWE,
        scale: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_mv_extract_tlwe_scaling_subto(
        out: TLWE,
        in_: TRLWE,
        scale: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_copy(out: TRLWE, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_negate(out: TRLWE, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_DFT_copy(out: TRLWE_DFT, in_: TRLWE_DFT);
}
extern "C" {
    pub fn free_trlwe(p_v: *mut ::libc::c_void);
}
extern "C" {
    pub fn free_trlwe_array(p_v: *mut ::libc::c_void, count: ::libc::c_int);
}
extern "C" {
    pub fn free_trlwe_key(key: TRLWE_Key);
}
extern "C" {
    pub fn trlwe_DFT_add(out: TRLWE_DFT, in1: TRLWE_DFT, in2: TRLWE_DFT);
}
extern "C" {
    pub fn trlwe_DFT_addto(out: TRLWE_DFT, in_: TRLWE_DFT);
}
extern "C" {
    pub fn trlwe_noiseless_trivial_DFT_sample(
        out: TRLWE_DFT,
        m: DFT_Polynomial,
    );
}
extern "C" {
    pub fn trlwe_new_noiseless_trivial_DFT_sample(
        m: DFT_Polynomial,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE_DFT;
}
extern "C" {
    pub fn trlwe_tensor_prod(
        out: TRLWE,
        in1: TRLWE,
        in2: TRLWE,
        delta: ::libc::c_int,
        rl_key: TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_tensor_prod_FFT(
        out: TRLWE,
        in1: TRLWE,
        in2: TRLWE,
        precision: ::libc::c_int,
        rl_key: TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_torus_packing_many_LUT(
        out: TRLWE,
        in_: *mut Torus,
        lut_size: ::libc::c_int,
        n_luts: ::libc::c_int,
    );
}
extern "C" {
    pub fn trlwe_eval_automorphism(
        out: TRLWE,
        in_: TRLWE,
        gen: u64,
        ks_key: TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_new_compressed_sample(
        m: TorusPolynomial,
        key: TRLWE_Key,
    ) -> TRLWE;
}
extern "C" {
    pub fn trlwe_load_new_compressed_sample(
        fd: *mut FILE,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRLWE;
}
extern "C" {
    pub fn trlwe_load_compressed_sample(fd: *mut FILE, c: TRLWE);
}
extern "C" {
    pub fn trlwe_save_compressed_sample(fd: *mut FILE, c: TRLWE);
}
extern "C" {
    pub fn trlwe_compressed_subto(out: TRLWE, in_: TRLWE);
}
extern "C" {
    pub fn trlwe_compressed_DFT_sample(
        out: TRLWE_DFT,
        m: TorusPolynomial,
        key: TRLWE_Key,
    );
}
extern "C" {
    pub fn trlwe_new_compressed_DFT_sample(
        m: TorusPolynomial,
        key: TRLWE_Key,
    ) -> TRLWE_DFT;
}
extern "C" {
    pub fn trlwe_compressed_DFT_mul_addto(
        out: TRLWE_DFT,
        in1: DFT_Polynomial,
        in2: TRLWE_DFT,
    );
}
extern "C" {
    pub fn trgsw_new_key(
        trlwe_key: TRLWE_Key,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
    ) -> TRGSW_Key;
}
extern "C" {
    pub fn trgsw_save_key(fd: *mut FILE, key: TRGSW_Key);
}
extern "C" {
    pub fn trgsw_load_new_key(fd: *mut FILE) -> TRGSW_Key;
}
extern "C" {
    pub fn trgsw_alloc_new_sample(
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW;
}
extern "C" {
    pub fn trgsw_alloc_new_sample_array(
        count: ::libc::c_int,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> *mut TRGSW;
}
extern "C" {
    pub fn trgsw_alloc_new_DFT_sample(
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW_DFT;
}
extern "C" {
    pub fn trgsw_alloc_new_DFT_sample_array(
        count: ::libc::c_int,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> *mut TRGSW_DFT;
}
extern "C" {
    pub fn trgsw_new_noiseless_trivial_sample(
        m: Torus,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW;
}
extern "C" {
    pub fn trgsw_noiseless_trivial_sample(
        out: TRGSW,
        m: Torus,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    );
}
extern "C" {
    pub fn trgsw_new_monomial_sample(
        m: i64,
        e: ::libc::c_int,
        key: TRGSW_Key,
    ) -> TRGSW;
}
extern "C" {
    pub fn trgsw_monomial_sample(
        out: TRGSW,
        m: i64,
        e: ::libc::c_int,
        key: TRGSW_Key,
    );
}
extern "C" {
    pub fn trgsw_new_sample(m: Torus, key: TRGSW_Key) -> TRGSW;
}
extern "C" {
    pub fn trgsw_new_exp_sample(e: ::libc::c_int, key: TRGSW_Key) -> TRGSW;
}
extern "C" {
    pub fn trgsw_load_new_sample(
        fd: *mut FILE,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW;
}
extern "C" {
    pub fn trgsw_load_sample(fd: *mut FILE, c: TRGSW);
}
extern "C" {
    pub fn trgsw_load_DFT_sample(fd: *mut FILE, out: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_save_DFT_sample(fd: *mut FILE, c: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_load_new_DFT_sample(
        fd: *mut FILE,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW_DFT;
}
extern "C" {
    pub fn trgsw_save_sample(fd: *mut FILE, c: TRGSW);
}
extern "C" {
    pub fn trgsw_sub(out: TRGSW, in1: TRGSW, in2: TRGSW);
}
extern "C" {
    pub fn trgsw_add(out: TRGSW, in1: TRGSW, in2: TRGSW);
}
extern "C" {
    pub fn trgsw_DFT_sub(out: TRGSW_DFT, in1: TRGSW_DFT, in2: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_addto(out: TRGSW, in_: TRGSW);
}
extern "C" {
    pub fn trgsw_mul_by_xai(out: TRGSW, in_: TRGSW, a: ::libc::c_int);
}
extern "C" {
    pub fn trgsw_mul_by_xai_addto(out: TRGSW, in_: TRGSW, a: ::libc::c_int);
}
extern "C" {
    pub fn trgsw_mul_by_xai_minus_1(out: TRGSW, in_: TRGSW, a: ::libc::c_int);
}
extern "C" {
    pub fn trgsw_to_DFT(out: TRGSW_DFT, in_: TRGSW);
}
extern "C" {
    pub fn trgsw_from_DFT(out: TRGSW, in_: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_mul_trlwe_DFT(out: TRLWE_DFT, in1: TRLWE, in2: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_mul_DFT2(out: TRGSW_DFT, in1: TRGSW_DFT, in2: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_mul_DFT(out: TRGSW_DFT, in1: TRGSW, in2: TRGSW_DFT);
}
extern "C" {
    pub fn trgsw_naive_mul_trlwe(out: TRLWE, in1: TRLWE, in2: TRGSW);
}
extern "C" {
    pub fn trgsw_naive_mul(out: TRGSW, in1: TRGSW, in2: TRGSW);
}
extern "C" {
    pub fn trgsw_copy(out: TRGSW, in_: TRGSW);
}
extern "C" {
    pub fn trgsw_DFT_copy(out: TRGSW_DFT, in_: TRGSW_DFT);
}
extern "C" {
    pub fn free_trgsw(p: *mut ::libc::c_void);
}
extern "C" {
    pub fn free_trgsw_array(p_v: *mut ::libc::c_void, count: ::libc::c_int);
}
extern "C" {
    pub fn free_trgsw_key(key: TRGSW_Key);
}
extern "C" {
    pub fn trgsw_mul_trlwe_DFT_prefetch(
        out: TRLWE_DFT,
        in1: TRLWE,
        in2: TRGSW_DFT,
    );
}
extern "C" {
    pub fn trgsw_DFT_mul_addto_by_polynomial(
        out: TRGSW_DFT,
        in1: TRGSW_DFT,
        in2: DFT_Polynomial,
    );
}
extern "C" {
    pub fn trgsw_reg_alloc(
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> TRGSW_REG;
}
extern "C" {
    pub fn trgsw_reg_alloc_array(
        count: ::libc::c_int,
        l: ::libc::c_int,
        Bg_bit: ::libc::c_int,
        k: ::libc::c_int,
        N: ::libc::c_int,
    ) -> *mut TRGSW_REG;
}
extern "C" {
    pub fn trgsw_reg_sample(out: TRGSW_REG, m: Torus, key: TRGSW_Key);
}
extern "C" {
    pub fn trgsw_reg_copy(out: TRGSW_REG, in_: TRGSW_REG);
}
extern "C" {
    pub fn trgsw_reg_add(out: TRGSW_REG, in1: TRGSW_REG, in2: TRGSW_REG);
}
extern "C" {
    pub fn trgsw_reg_negate(reg: TRGSW_REG);
}
extern "C" {
    pub fn trgsw_reg_sub(out: TRGSW_REG, in1: TRGSW_REG, in2: TRGSW_REG);
}
extern "C" {
    pub fn trgsw_reg_subto(out: TRGSW_REG, in_: TRGSW_REG);
}
extern "C" {
    pub fn trgsw_reg_addto(out: TRGSW_REG, in1: TRGSW_REG);
}
extern "C" {
    pub fn free_trgsw_reg(p: TRGSW_REG);
}
extern "C" {
    pub fn free_trgsw_reg_array(p: *mut TRGSW_REG, count: ::libc::c_int);
}
extern "C" {
    pub fn trlwe_new_KS_key(
        out_key: TRLWE_Key,
        in_key: TRLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_keyswitch(out: TRLWE, in_: TRLWE, ks_key: TRLWE_KS_Key);
}
extern "C" {
    pub fn free_trlwe_ks_key(key: TRLWE_KS_Key);
}
extern "C" {
    pub fn trlwe_new_packing_KS_key(
        out_key: TRLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
        torus_base: ::libc::c_int,
    ) -> LUT_Packing_KS_Key;
}
extern "C" {
    pub fn trlwe_packing_keyswitch(
        out: TRLWE,
        in_: *mut TLWE,
        ks_key: LUT_Packing_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_load_new_packing_KS_key(fd: *mut FILE) -> LUT_Packing_KS_Key;
}
extern "C" {
    pub fn trlwe_save_packing_KS_key(fd: *mut FILE, key: LUT_Packing_KS_Key);
}
extern "C" {
    pub fn trlwe_torus_packing(
        out: TRLWE,
        in_: *mut Torus,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn free_trlwe_packing_ks_key(key: LUT_Packing_KS_Key);
}
extern "C" {
    pub fn trlwe_new_RL_key(
        key: TRLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_packing1_keyswitch(
        out: TRLWE,
        in_: TLWE,
        ks_key: Generic_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_new_priv_SK_KS_key(
        out_key: TRLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> Generic_KS_Key;
}
extern "C" {
    pub fn trlwe_priv_keyswitch(out: TRLWE, in_: TLWE, ks_key: Generic_KS_Key);
}
extern "C" {
    pub fn free_trlwe_generic_ks_key(key: Generic_KS_Key);
}
extern "C" {
    pub fn trlwe_new_packing1_KS_key(
        out_key: TRLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> Generic_KS_Key;
}
extern "C" {
    pub fn trlwe_new_packing1_KS_key_CDKS21(
        out_key: TRLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> *mut TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_packing1_keyswitch_CDKS21(
        out: TRLWE,
        in_: TLWE,
        ks_key: *mut TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_new_automorphism_KS_keyset(
        key: TRLWE_Key,
        skip_even: bool,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> *mut TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_new_full_packing_KS_key(
        out_key: TRLWE_Key,
        in_key: TLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_full_packing_keyswitch(
        out: TRLWE,
        in_: *mut TLWE,
        size: u64,
        ks_key: TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_save_generic_ks_key(fd: *mut FILE, key: Generic_KS_Key);
}
extern "C" {
    pub fn trlwe_load_new_generic_ks_key(fd: *mut FILE) -> Generic_KS_Key;
}
extern "C" {
    pub fn trlwe_new_priv_KS_key(
        out_key: TRLWE_Key,
        in_key: TRLWE_Key,
        t: ::libc::c_int,
        base_bit: ::libc::c_int,
    ) -> *mut TRLWE_KS_Key;
}
extern "C" {
    pub fn trlwe_priv_keyswitch_2(
        out: TRLWE,
        in_: TRLWE,
        ks_key: *mut TRLWE_KS_Key,
    );
}
extern "C" {
    pub fn trlwe_save_KS_key(fd: *mut FILE, key: TRLWE_KS_Key);
}
extern "C" {
    pub fn trlwe_load_new_KS_key(fd: *mut FILE) -> TRLWE_KS_Key;
}
extern "C" {
    pub fn new_bootstrap_key(
        out_key: TRGSW_Key,
        in_key: TLWE_Key,
        unfolding: ::libc::c_int,
    ) -> Bootstrap_Key;
}
extern "C" {
    pub fn blind_rotate(
        tv: TRLWE,
        a: *mut Torus,
        s: *mut TRGSW_DFT,
        size: ::libc::c_int,
    );
}
extern "C" {
    pub fn functional_bootstrap_wo_extract(
        out: TRLWE,
        tv: TRLWE,
        in_: TLWE,
        s: Bootstrap_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn multivalue_bootstrap_phase1(
        out: *mut TRLWE,
        in_: TLWE,
        s: Bootstrap_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn multivalue_bootstrap_phase2(
        out: TLWE,
        in_: *mut ::libc::c_int,
        rotated_tv: *mut TRLWE,
        torus_base: ::libc::c_int,
        log_torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn functional_bootstrap_trgsw_phase1(
        out: TRGSW_DFT,
        in_: TLWE,
        s: Bootstrap_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn functional_bootstrap_trgsw_phase2(
        out: TLWE,
        in_: TRGSW_DFT,
        tv: TRLWE,
    );
}
extern "C" {
    pub fn free_bootstrap_key(key: Bootstrap_Key);
}
extern "C" {
    pub fn save_bootstrap_key(fd: *mut FILE, key: Bootstrap_Key);
}
extern "C" {
    pub fn load_new_bootstrap_key(fd: *mut FILE) -> Bootstrap_Key;
}
extern "C" {
    pub fn multivalue_bootstrap_CLOT21(
        out: *mut TLWE,
        tv: TRLWE,
        in_: TLWE,
        key: Bootstrap_Key,
        torus_base: ::libc::c_int,
        n_luts: ::libc::c_int,
    );
}
extern "C" {
    pub fn multivalue_bootstrap_UBR_phase1(
        out: *mut TRGSW_DFT,
        in_: TLWE,
        key: Bootstrap_Key,
    );
}
extern "C" {
    pub fn multivalue_bootstrap_UBR_phase2(
        out: TLWE,
        tv: TRLWE,
        in_: TLWE,
        sa: *mut TRGSW_DFT,
        key: Bootstrap_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn generate_rnd_seed(p: *mut u64);
}
extern "C" {
    pub fn generate_random_bytes(amount: u64, pointer: *mut u8);
}
extern "C" {
    pub fn generate_normal_random(sigma: f64) -> f64;
}
extern "C" {
    pub fn generate_torus_normal_random_array(
        out: *mut Torus,
        sigma: f64,
        N: ::libc::c_int,
    );
}
extern "C" {
    pub fn new_bootstrap_key_ga(
        out_key: TRGSW_Key,
        in_key: TLWE_Key,
    ) -> Bootstrap_GA_Key;
}
extern "C" {
    pub fn functional_bootstrap_wo_extract_ga(
        out: TRLWE,
        tv: TRLWE,
        in_: TLWE,
        key: Bootstrap_GA_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn functional_bootstrap_ga(
        out: TLWE,
        tv: TRLWE,
        in_: TLWE,
        key: Bootstrap_GA_Key,
        torus_base: ::libc::c_int,
    );
}
extern "C" {
    pub fn free_bootstrap_key_ga(key: Bootstrap_GA_Key);
}
